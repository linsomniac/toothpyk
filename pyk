#!/usr/bin/env python3
#
#  A small multi-use tool for the command-line.
#
#  Sean Reifschneider 2023 <jafo00@gmail.com>

import argparse
import sys
import socket
import time
import re
from typing import Union, Callable

class DocstringDescriptionFormatter(argparse.HelpFormatter):
    def _fill_text(self, text, width, indent):
        return '\n'.join([line.lstrip() for line in text.splitlines()])

# create the top-level parser
parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(required=True, title="Commands")


def func_to_help(func: Callable) -> Union[None, str]:
    "Returns the first line of the docstr"
    if not func.__doc__:
        return None
    return func.__doc__.split("\n")[0]


def func_to_desc(func: Callable) -> Union[None, str]:
    "Returns the full docstring"
    if not func.__doc__:
        return None
    return func.__doc__


def bytesToStr(bytes: int) -> str:
    try:
        if bytes > 1024000:
            return "%.3fM" % (bytes / 1024000.0)
        if bytes > 1024:
            return "%.3fK" % (bytes / 1024.0)
        return "%dB" % (bytes)
    except OverflowError:
        return '[Invalid: "%s"]' % str(bytes)


def do_send(args):
    """Connect to a socket and send data to it.

    This can connect to a remote socket and then send either stdin or a file
    to the remote socket.
    """
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect(addr)
    buf = bytearray(4096)

    bytes = 0
    last = 0
    while True:
        data_len = args.input.readinto(buf)
        if data_len < 1:
            break
        s.send(buf[:data_len])
        bytes = bytes + data_len
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


subparser = subparsers.add_parser(
    "send", help=func_to_help(do_send), description=func_to_desc(do_send),
    formatter_class=DocstringDescriptionFormatter
)
subparser.add_argument(
    "--input",
    "-i",
    nargs="?",
    type=argparse.FileType("rb"),
    default=sys.stdin.buffer,
)
subparser.add_argument("host")
subparser.add_argument("port", type=int)
subparser.set_defaults(func=do_send)


def do_receive(args):
    """Listen on a socket and when a connection comes in read data from it.

    This can be used to receive data from a remote machine, this function binds
    to a network socket and waits for something to connect, then reads data and
    writes it out to a file or stdout.
    """
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    s.bind(addr)
    s.listen(1)
    conn, addr = s.accept()
    sys.stderr.write("Connected by %s\n" % str(addr))

    bytes = 0
    last = 0
    while True:
        data = conn.recv(4096)
        if not data:
            break
        args.output.write(data)
        bytes = bytes + len(data)
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


subparser = subparsers.add_parser(
    "receive",
    aliases=["recv"],
    help=func_to_help(do_receive),
    description=func_to_desc(do_receive),
    formatter_class=DocstringDescriptionFormatter
)
subparser.add_argument(
    "--output",
    "-o",
    nargs="?",
    type=argparse.FileType("wb"),
    default=sys.stdout.buffer,
)
subparser.add_argument("--host", default="")
subparser.add_argument("port", type=int)
subparser.set_defaults(func=do_receive)


def do_rsend(args):
    """Listen on a socket and when a connection comes in send data to it.

    This is like "send" but with the listener on the other end (for diversity, if one
    end is firewalled off).
    """
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    s.bind(addr)
    s.listen(1)
    conn, addr = s.accept()
    sys.stderr.write("Connected by %s\n" % str(addr))
    buf = bytearray(4096)

    bytes = 0
    last = 0
    while True:
        data_len = args.input.readinto(buf)
        if data_len < 1:
            break
        conn.send(buf[:data_len])
        bytes = bytes + data_len
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


subparser = subparsers.add_parser(
    "rsend", help=func_to_help(do_rsend), description=func_to_desc(do_rsend),
    formatter_class=DocstringDescriptionFormatter
)
subparser.add_argument(
    "--input",
    "-i",
    nargs="?",
    type=argparse.FileType("rb"),
    default=sys.stdin.buffer,
)
subparser.add_argument("--host", default="")
subparser.add_argument("port", type=int)
subparser.set_defaults(func=do_rsend)


def do_rreceive(args):
    """Connect to a socket and read data from it.

    This is like "receive" but data flowing the opposite direction.  This
    is for use with "rsend".
    """
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect(addr)

    bytes = 0
    last = 0
    while True:
        data = s.recv(4096)
        if not data:
            break
        args.output.write(data)
        bytes = bytes + len(data)
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


subparser = subparsers.add_parser(
    "rreceive",
    aliases=["rrecv"],
    help=func_to_help(do_rreceive),
    description=func_to_desc(do_rreceive),
    formatter_class=DocstringDescriptionFormatter
)
subparser.add_argument(
    "--output",
    "-o",
    nargs="?",
    type=argparse.FileType("wb"),
    default=sys.stdout.buffer,
)
subparser.add_argument("host")
subparser.add_argument("port", type=int)
subparser.set_defaults(func=do_rreceive)


def do_eval(args):
    """Evaluate a Python expression and return the result.  Can be used as a simple infix calculator.

    This implements the "EP" part of "REPL", evaluating short bits of Python, for example
    dec/hex/oct conversion, simple calculations, etc...
    """
    cmd = " ".join(args.rest)
    print(eval(cmd))


subparser = subparsers.add_parser(
    "eval", aliases=["e"], help=func_to_help(do_eval), description=func_to_desc(do_eval),
    formatter_class=DocstringDescriptionFormatter
)
subparser.add_argument("rest", nargs="*")
subparser.set_defaults(func=do_eval)


def do_rpncalc(args):
    """An RPN desk calculator, use comma like Enter and 'x' can be used for multiply.


    An example computation would be "2,3*" or "2,3x" to multiply 2*3 ("x" to avoid
    command-line globbing).  Also supports +, -, and /.
    """
    input = "".join(args.rest)

    stack = []
    operators = {
        "x": lambda x, y: x * y,
        "*": lambda x, y: x * y,
        "/": lambda x, y: x / y,
        "+": lambda x, y: x + y,
        "-": lambda x, y: x - y,
    }

    def gen_ops(input):
        rx = re.compile(
            r"^((?P<number>[0-9]+(\.[0-9]*)?)|(?P<operator>[-,x/+*]))(?P<rest>.*)$"
        )
        while input:
            m = rx.match(input)
            if not m:
                raise ValueError('Could not understand "{input}"')
            d = m.groupdict()
            input = d["rest"]
            if d["number"]:
                yield float(d["number"]) if "." in d["number"] else int(d["number"])
                continue
            if d["operator"]:
                yield d["operator"]

    for x in gen_ops(input):
        if x == ",":
            pass
        elif x in operators:
            a = stack.pop()
            b = stack.pop()
            result = operators[x](b, a)
            stack.append(result)
        else:
            stack.append(x)

    print(stack[-1])


subparser = subparsers.add_parser(
    "rpncalc",
    aliases=["rc"],
    help=func_to_help(do_rpncalc),
    description=func_to_desc(do_rpncalc),
)
subparser.add_argument("rest", nargs="*")
subparser.set_defaults(func=do_rpncalc)


def main():
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
