#!/usr/bin/env python3
#
#  A small multi-use tool for the command-line.
#
#  Sean Reifschneider 2023 <jafo00@gmail.com>

import argparse
import sys
import socket
import time
import re


def bytesToStr(bytes: int) -> str:
    try:
        if bytes > 1024000:
            return "%.3fM" % (bytes / 1024000.0)
        if bytes > 1024:
            return "%.3fK" % (bytes / 1024.0)
        return "%dB" % (bytes)
    except OverflowError:
        return '[Invalid: "%s"]' % str(bytes)


def do_send(args):
    "Connect to a socket and send data to it."
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect(addr)
    buf = bytearray(4096)

    bytes = 0
    last = 0
    while True:
        data_len = args.input.readinto(buf)
        if data_len < 1:
            break
        s.send(buf[:data_len])
        bytes = bytes + data_len
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


def do_receive(args):
    "Listen on a socket and when a connection comes in read data from it."
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    s.bind(addr)
    s.listen(1)
    conn, addr = s.accept()
    sys.stderr.write("Connected by %s\n" % str(addr))

    bytes = 0
    last = 0
    while True:
        data = conn.recv(4096)
        if not data:
            break
        args.output.write(data)
        bytes = bytes + len(data)
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


def do_rsend(args):
    "Listen on a socket and when a connection comes in send data to it."
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    s.bind(addr)
    s.listen(1)
    conn, addr = s.accept()
    sys.stderr.write("Connected by %s\n" % str(addr))
    buf = bytearray(4096)

    bytes = 0
    last = 0
    while True:
        data_len = args.input.readinto(buf)
        if data_len < 1:
            break
        conn.send(buf[:data_len])
        bytes = bytes + data_len
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


def do_rreceive(args):
    "Connect to a socket and read data from it."
    addr = (args.host, args.port)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect(addr)

    bytes = 0
    last = 0
    while True:
        data = s.recv(4096)
        if not data:
            break
        args.output.write(data)
        bytes = bytes + len(data)
        now = int(time.time())
        if now != last:
            sys.stderr.write(f" {bytesToStr(bytes):20}\r")
        last = now
    sys.stderr.write(f" {bytesToStr(bytes):20}\n")


def do_eval(args):
    "Evaluate a Python expression and return the result.  Can be used as a simple infix calculator."
    cmd = " ".join(args.rest)
    print(eval(cmd))


def do_rpncalc(args):
    "An RPN desk calculator, use comma like Enter and 'x' can be used for multiply."
    input = "".join(args.rest)

    stack = []
    operators = {
        "x": lambda x, y: x * y,
        "*": lambda x, y: x * y,
        "/": lambda x, y: x / y,
        "+": lambda x, y: x + y,
        "-": lambda x, y: x - y,
    }

    def gen_ops(input):
        rx = re.compile(
            r"^((?P<number>[0-9]+(\.[0-9]*)?)|(?P<operator>[,x/+-]))(?P<rest>.*)$"
        )
        while input:
            m = rx.match(input)
            if not m:
                raise ValueError('Could not understand "{input}"')
            d = m.groupdict()
            input = d["rest"]
            if d["number"]:
                yield float(d["number"]) if "." in d["number"] else int(d["number"])
                continue
            if d["operator"]:
                yield d["operator"]

    for x in gen_ops(input):
        if x == ",":
            pass
        elif x in operators:
            a = stack.pop()
            b = stack.pop()
            result = operators[x](b, a)
            stack.append(result)
        else:
            stack.append(x)

    print(stack[-1])


def main():
    # create the top-level parser
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(required=True, title="Commands")

    #  SEND
    parser_send = subparsers.add_parser("send", help=do_send.__doc__)
    parser_send.add_argument(
        "--input",
        "-i",
        nargs="?",
        type=argparse.FileType("rb"),
        default=sys.stdin.buffer,
    )
    parser_send.add_argument("host")
    parser_send.add_argument("port", type=int)
    parser_send.set_defaults(func=do_send)

    #  RECEIVE
    parser_send = subparsers.add_parser(
        "receive", aliases=["recv"], help=do_rreceive.__doc__
    )
    parser_send.add_argument(
        "--output",
        "-o",
        nargs="?",
        type=argparse.FileType("wb"),
        default=sys.stdout.buffer,
    )
    parser_send.add_argument("--host", default="")
    parser_send.add_argument("port", type=int)
    parser_send.set_defaults(func=do_receive)

    #  RSEND
    parser_rsend = subparsers.add_parser("rsend", help=do_rsend.__doc__)
    parser_rsend.add_argument(
        "--input",
        "-i",
        nargs="?",
        type=argparse.FileType("rb"),
        default=sys.stdin.buffer,
    )
    parser_rsend.add_argument("--host", default="")
    parser_rsend.add_argument("port", type=int)
    parser_rsend.set_defaults(func=do_rsend)

    #  RRECEIVE
    parser_rreceive = subparsers.add_parser(
        "rreceive", aliases=["rrecv"], help=do_rreceive.__doc__
    )
    parser_rreceive.add_argument(
        "--output",
        "-o",
        nargs="?",
        type=argparse.FileType("wb"),
        default=sys.stdout.buffer,
    )
    parser_rreceive.add_argument("host")
    parser_rreceive.add_argument("port", type=int)
    parser_rreceive.set_defaults(func=do_rreceive)

    #  EVAL
    parser_eval = subparsers.add_parser("eval", aliases=["e"], help=do_eval.__doc__)
    parser_eval.add_argument("rest", nargs="*")
    parser_eval.set_defaults(func=do_eval)

    #  RPNCALC
    parser_rc = subparsers.add_parser(
        "rpncalc", aliases=["rc"], help=do_rpncalc.__doc__
    )
    parser_rc.add_argument("rest", nargs="*")
    parser_rc.set_defaults(func=do_rpncalc)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
